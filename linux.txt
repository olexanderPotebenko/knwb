----------------------------------------------------------------------
получить man на другом языке
man --locale=ru vim
----------------------------------------------------------------------

Установка linux на флешку:

sudo fdisk -l

на устойство /dev/sdb

файловая система fat32

sudo dd if=path.iso of=/dev/sdb

----------------------------------------------------------------------

Как изменить терминал по умолчанию:
sudo update-alternatives --config x-terminal-emulator

----------------------------------------------------------------------

как узнать кто слушает порт
sudo netstat -ltnp | grep -w ':80'

$ sudo netstat -ltnp | grep -w ':80'


Check-Port-Using-netstat-Command
В приведенной выше команде используются следующие опции:

l — указывает netstat, — на то, что необходимо показывать только прослушивающие сокеты.
t — указывает на отображение tcp-соединений.
n — указывает на то, что необходимо показывать ip-адреса.
p — позволяет показывать идентификатор процесса и имя процесса.
grep -w — показывает соответствие точной строки (‘:80’).

---------------------------------------------------------------------
как убивать процессы
Убиваем процессы в Linux — команды ps, kill и killall
34

Не смотря на свою стабильность, некоторые приложения в Linux иногда виснут. Иногда приложения перестают отзываться или просто работают так медленно, что корректно закрыть их не получается. Один из способов «убить», запущенное приложение в Linux, это использование таких команд, как kill или killall. Рассмотрим, как использовать эти команды, находить PID процесса и посылать сигнал SIGKILL.
Под процессом мы будем понимать запущенную в системе копию программы. Например, если вы открыли три окна калькулятора (например, gcalctool), это значит, что вы запустили три процесса.

Находим PID зависшего процесса
Каждый процесс в Linux имеет свой идентификатор, называемый PID. Перед тем, как выполнить остановку процесса, нужно определить его PID. Для этого воспользуемся командами ps и grep. Команда ps предназначена для вывода списка активных процессов в системе и информации о них. Команда grep запускается одновременно с ps (в канале) и будет выполнять поиск по результатам команды ps. Вывести список всех процессов можно, выполнив в командной строке:

ps axu
 Но, как правило, список очень большой и найти процесс, который мы хотим «убить», бывает не так просто. Здесь на помощь приходит команда grep. Например, чтобы найти информацию о процессе с именем gcalctool выполните команду:

ps axu | grep gcalctool
Команда grep выполнит поиск по результатам команды ps и на экран будут выведены только те строки, которые содержат строку (слово) gcalctool. Здесь есть одна интересная деталь, например, если у вас не запущено приложение gcalctool, то после выполнения ps axu | grep gcalctool вы получите:

$ ps axu | grep gcalctool
yuriy 25587 0.0 0.0 10636 884 pts/2 S+ 10:20 0:00 grep --color=auto gcalctool
То есть мы получили сам процесс grep, так как в качестве параметра команде мы указали слово gcalctool, и grep нашел сам себя в выводе команды ps.

Если процесс gcalctool запущен, то мы получим:

yuriy@yuriy-NIX:~$ ps axu | grep gcalctool
yuriy 25609 7.6 0.4 500840 17964 ? Sl 10:20 0:00 gcalctool
yuriy 25624 0.0 0.0 10640 884 pts/2 S+ 10:21 0:00 grep --color=auto gcalctool
Здесь нас интересует строка: «yuriy 25609 7.6 0.4 500840 17964 ? Sl 10:20 0:00 gcalctool». Число 25609 и есть идентификатор (PID) процесса gcalctool.

Есть еще один более простой способ узнать PID процесса — это команда pidof, которая принимает в качестве параметра название процесса и выводит его PID. Пример выполнения команды pidof:

$ pidof gcalctool
25609
«Убиваем» процесс командой kill
Когда известен PID процесса, мы можем убить его командой kill. Команда kill принимает в качестве параметра PID процесса. Например, убьем процесс с номером 25609:

kill 25609
Вообще команда kill предназначена для посылки сигнала процессу. По умолчанию, если мы не указываем какой сигнал посылать, посылается сигнал SIGTERM (от слова termination — завершение). SIGTERM указывает процессу на то, что необходимо завершиться. Каждый сигнал имеет свой номер. SIGTERM имеет номер 15. Список всех сигналов (и их номеров), которые может послать команда kill, можно вывести, выполнив kill -l. Чтобы послать сигнал SIGKILL (он имеет номер 9) процессу 25609, выполните в командой строке:

kill -9 25609
Сигнал SIGTERM может и не остановить процесс (например, при перехвате или блокировке сигнала), SIGKILL же выполняет уничтожение процесса всегда, так как его нельзя перехватить или проигнорировать.

Убиваем процессы командой killall
Команда killall в Linux предназначена для «убийства» всех процессов, имеющих одно и то же имя. Это удобно, так как нам не нужно знать PID процесса. Например, мы хотим закрыть все процессы с именем gcalctool. Выполните в терминале:

killall gcalctool
Команда killall, также как и kill, по умолчанию шлет сигнал SIGTERM. Чтобы послать другой сигнал нужно воспользоваться опцией -s. Например:

killall -s 9 gcalctool
Заключение
Некоторые процессы не удается остановить под обычным пользователем. Например, если процесс был запущен от имени пользователя root или от имени другого пользователя системы, то команды kill и killall нужно выполнять от имени суперпользователя, добавляя sudo (в Ubuntu):

sudo kill 123
Бывают ситуации, когда вы работаете в графическом интерфейсе (например, GNOME) и вам не удается открыть эмулятор терминала, чтобы остановить зависший процесс. Тогда можно переключиться на виртуальную консоль клавишами Ctrl+Alt+F1, залогиниться в ней и выполнять команды уже из нее. А потом перейти обратно, нажав Ctrl+Alt+F7.
---------------------------------------------------------------------

Изменить пользователя папки

sudo chown -R l . 
----------------------------------------------------------------------
работа утилиты find

как удалить все файлы, что заканчиваются на "str"
find /directory -delete -name '*str'
---------------------------------------------------------------------
работа утилиты grep

grep -rin --include='*.css' 'inline-block' . // n - вывод с номерами строк
// include - в каких файлах искать
---------------------------------------------------------------------
очистка swap-файла

swapoff -a // выключить swap
swapon -a // включить swap

cat /proc/sys/vm/swappiness / выведет процент загрузки оперативной памяти, при котором подключаеться swap


sudo sysctl -w vm.swappiness=10 / при 90% зарузки оперативной памяти подключаеться swap

 /etc/sysctl.conf строку vm.swappiness=25 /постоянный файл подкачки

vm.vfs_cache_pressure = 1000

sudo sysctl -p

----------------------------------------------------

zram и приоритеты свопов

Рекомендую включить zram — прозрачное сжатие содержимого оперативной памяти. В Ubuntu это автоматизировано, достаточно установить пакет:

sudo apt install zram-config

Здесь и далее для дистрибутивов Rosa, Fedora все то же самое, но вместо zram-config —

zram-start.

Сервис systemd zram-config на Ubuntu будет автоматически добавлен в автозагрузку при установке пакета и запущен при перезагрузке системы. Для запуска вручную:

sudo systemctl start zram-config

остановки:

sudo systemctl stop zram-config

Удаления из автозапуска:

sudo systemctl disable zram-config

Добавление в автозапуск:

sudo systemctl enable zram-config

При запуске zram-config берет число, равное 50% всего объема оперативной памяти, далее делает по одному виртуальному устройству /dev/zramN, где N начинается с 0, для каждого ядра процессора, а объем каждого /dev/zramN равен 50% всей оперативной памяти, деленному на количество ядер процессора. Так делалается для распараллеливания сжатия содержимого оперативной памяти по ядрам процессора; насколько я знаю, на современных ядрах Linux достаточно одного устройства /dev/zramN, а распараллелится оно само, но меня полностью устраивает искоробочная работа zram-config, и предпочитаю не лезть в нее руками.

Команда swapon -s выведет список всех задействованных свопов с указанием их приоритета. Первым используется тот своп, у которого приоритет выше. Если у вас уже есть дисковый своп и включен zram, то в случае с описанным выше пакетом-автокофигуратором приоритеты из коробки будут правильными. Например, у дискового свопа будет -1, а все /dev/zramN — 5. Таким образом, сначала используется zram, и только потом — диск.

----------------------------------------------------
cron

crontab -e # открыть /tmp/crontab.weH2cw/crontab















